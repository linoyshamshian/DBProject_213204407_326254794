import customtkinter as ctk
import psycopg2
from psycopg2 import sql
import random
import string
from CTkMessagebox import CTkMessagebox


# --- Database Schema/Column Type Detection ---

def get_column_details(cursor, table_name):
    """
    Retrieves column details (name, data type, and if it's a serial-like default)
    for a given table from information_schema and pg_catalog.
    """
    try:
        cursor.execute(
            """
            SELECT column_name, data_type, column_default
            FROM information_schema.columns
            WHERE table_schema = %s
              AND table_name = %s
            ORDER BY ordinal_position
            """,
            ('public', table_name.lower())
        )
        basic_cols_info = cursor.fetchall()

        detailed_columns = []
        for col_name, data_type, column_default in basic_cols_info:
            is_serial_like = False
            if column_default and "nextval" in column_default:
                cursor.execute(
                    """
                    SELECT c.relkind = 'S'
                    FROM pg_class c
                             JOIN pg_depend d ON d.objid = c.oid
                             JOIN pg_attribute a ON a.attrelid = d.refobjid AND a.attnum = d.refobjsubid
                    WHERE d.refobjid = %s::regclass
                    AND a.attname = %s
                      AND d.deptype = 'a';
                    """,
                    (table_name.lower(), col_name)
                )
                res = cursor.fetchone()
                if res and res[0]:
                    is_serial_like = True

            detailed_columns.append({
                'name': col_name,
                'data_type': data_type,
                'is_serial_like': is_serial_like
            })
        return detailed_columns
    except Exception as e:
        print(f"Error fetching column details for {table_name}: {e}")
        return []


def get_primary_key_column(cursor, table_name):
    """
    Retrieves the primary key column name for a given table.
    """
    try:
        cursor.execute(
            """
            SELECT a.attname
            FROM pg_index ix
                     JOIN pg_attribute a ON a.attrelid = ix.indrelid
                AND a.attnum = ANY (ix.indkey)
            WHERE ix.indrelid = %s::regclass
            AND    ix.indisprimary;
            """,
            (table_name.lower(),)
        )
        pk_col = cursor.fetchone()
        return pk_col[0] if pk_col else None
    except Exception as e:
        print(f"Error fetching primary key for {table_name}: {e}")
        return None


# --- UI Functions ---

def create_entry_form(screen, table_columns_details, pk_col_name, on_save_callback, row_data=None):
    """
    Creates a form for creating or updating a table entry,
    handling primary keys based on their type.
    """
    form_screen = ctk.CTkToplevel(screen)
    form_screen.title("Edit/Create Entry")
    form_screen.geometry("450x600")
    form_screen.configure(fg_color="#eaf0ff")

    entries = {}  # Dictionary to store entry widgets
    pk_entry_widget = None  # To store the specific entry widget for the primary key

    form_title = "Create New Entry" if row_data is None else "Update Entry"
    ctk.CTkLabel(form_screen, text=form_title, font=("Segoe UI", 18, "bold"),
                 fg_color="#eaf0ff", text_color="#2a3f77").pack(pady=15)

    form_frame = ctk.CTkScrollableFrame(form_screen, fg_color="#f0f4ff")
    form_frame.pack(padx=20, pady=10, fill="both", expand=True)

    for i, col_detail in enumerate(table_columns_details):
        col_name = col_detail['name']
        data_type = col_detail['data_type']
        is_serial_like = col_detail['is_serial_like']

        ctk.CTkLabel(form_frame, text=f"{col_name}:", font=("Segoe UI", 13, "bold"),
                     text_color="#2a3f77").grid(row=i, column=0, padx=5, pady=8, sticky="w")

        if col_name == pk_col_name:
            if row_data is not None:  # Update mode - PK is read-only label
                label_value = ctk.CTkLabel(form_frame, text=str(row_data[i]), font=("Segoe UI", 12, "bold"))
                label_value.grid(row=i, column=1, padx=5, pady=8, sticky="ew")
            elif is_serial_like:  # Create mode, PK is SERIAL - initially empty/placeholder, disabled
                entry = ctk.CTkEntry(form_frame, width=220, state="disabled", text_color="grey")  # Disabled entry
                entry.insert(0, "<Auto-generated by DB>")  # Placeholder text
                entry.grid(row=i, column=1, padx=5, pady=8, sticky="ew")
                pk_entry_widget = entry  # Store reference to this specific widget
            else:  # Create mode, PK is NOT SERIAL - suggest value, editable
                entry = ctk.CTkEntry(form_frame, width=220)
                suggested_value = ""
                if data_type.startswith('int') or data_type == 'numeric':
                    suggested_value = str(random.randint(1000, 99999))
                elif data_type.startswith('char') or data_type == 'text':
                    suggested_value = ''.join(random.choices(string.ascii_uppercase + string.digits, k=8))
                entry.insert(0, suggested_value)
                entry.grid(row=i, column=1, padx=5, pady=8, sticky="ew")
                entries[col_name] = entry
        else:  # Regular field
            entry = ctk.CTkEntry(form_frame, width=220)
            entry.grid(row=i, column=1, padx=5, pady=8, sticky="ew")
            entries[col_name] = entry
            if row_data:
                entry.insert(0, str(row_data[i]))

    def on_save_clicked():
        data = {col: entries[col].get() for col in entries}
        # Pass pk_entry_widget so callback can update it
        if on_save_callback:
            on_save_callback(data, row_data, pk_col_name, form_screen, pk_entry_widget)

    ctk.CTkButton(form_screen, text="Save Changes", command=on_save_clicked,
                  fg_color="#4CAF50", hover_color="#45a049", text_color="white",
                  font=("Segoe UI", 14, "bold"), corner_radius=10, width=180, height=40).pack(pady=20)


def open_table_screen(cursor, table_name, conn):
    """
    Opens a screen to display, create, update, and delete table data.
    """
    columns_details = get_column_details(cursor, table_name)
    column_names = [col['name'] for col in columns_details]
    pk_col = get_primary_key_column(cursor, table_name)

    screen = ctk.CTkToplevel()
    screen.title(f"{table_name.capitalize()} Data")
    screen.geometry("1100x700")
    screen.configure(fg_color="#eaf0ff")

    ctk.CTkLabel(screen, text=f"Table: {table_name.capitalize()}", font=("Segoe UI", 28, "bold"),
                 fg_color="#eaf0ff", text_color="#2a3f77").pack(pady=20)

    data_frame = ctk.CTkScrollableFrame(screen, width=1050, height=500, fg_color="#f0f4ff")
    data_frame.pack(padx=20, pady=15, fill="both", expand=True)

    table_data_labels = []

    def refresh_table_data():
        """Refreshes the data displayed in the table and scrolls to the end."""
        for row_labels in table_data_labels:
            for label in row_labels:
                label.destroy()
        table_data_labels.clear()

        # Add column headers
        for idx, col_name in enumerate(column_names):
            ctk.CTkLabel(
                data_frame,
                text=col_name,
                width=150,
                anchor="center",
                font=("Segoe UI", 14, "bold"),
                fg_color="#dbe4ff",
                text_color="#2a3f77",
                padx=5, pady=8
            ).grid(row=0, column=idx, padx=2, pady=2, sticky="ew")

        # Fetch and display ALL data, ordered by PK to show new entries at the bottom
        # If pk_col is None (no PK found), order by first column, or simply without ORDER BY
        order_clause = f"ORDER BY {pk_col}" if pk_col else ""
        cursor.execute(f"SELECT * FROM {table_name.lower()} {order_clause}")
        rows = cursor.fetchall()

        for r_idx, row in enumerate(rows, start=1):
            row_labels = []
            for c_idx, value in enumerate(row):
                label = ctk.CTkLabel(
                    data_frame,
                    text=str(value),
                    width=150,
                    anchor="center",
                    font=("Segoe UI", 12),
                    fg_color="#ffffff",
                    text_color="black",
                    padx=5, pady=4
                )
                label.grid(row=r_idx, column=c_idx, padx=2, pady=1, sticky="ew")
                row_labels.append(label)

            for label in row_labels:
                label.bind("<Button-1>",
                           lambda event, r=row, current_screen=screen, pk_col_name=pk_col, table_name_ref=table_name,
                                  cursor_ref=cursor, conn_ref=conn, refresh_func=refresh_table_data:
                           show_row_context_menu(event, r, current_screen, pk_col_name, table_name_ref, cursor_ref,
                                                 conn_ref, refresh_func, column_names))

            table_data_labels.append(row_labels)

        # Scroll to the bottom to show newly added rows
        data_frame.after(100, lambda: data_frame._parent_canvas.yview_moveto(1.0))

    def handle_create_entry(data, original_row_data, pk_col_name, form_screen, pk_entry_widget_ref):
        """
        Handles creating a new entry in the database.
        Returns the newly created PK value if successful.
        """
        try:
            pk_detail = next((col for col in columns_details if col['name'] == pk_col_name), None)

            # Prepare columns and values for INSERT
            if pk_detail and pk_detail['is_serial_like']:
                insert_cols = [k for k in data.keys() if k != pk_col_name]
                insert_values = [data[k] for k in insert_cols]
            else:
                insert_cols = list(data.keys())
                insert_values = list(data.values())

            cols = sql.SQL(', ').join(sql.Identifier(k) for k in insert_cols)
            vals = sql.SQL(', ').join(sql.Placeholder() for _ in insert_values)

            # Add RETURNING clause to get the primary key back
            insert_query = sql.SQL("INSERT INTO {table} ({cols}) VALUES ({vals}) RETURNING {pk_col}").format(
                table=sql.Identifier(table_name.lower()),
                cols=cols,
                vals=vals,
                pk_col=sql.Identifier(pk_col_name)  # Request the PK value back
            )

            cursor.execute(insert_query, insert_values)
            new_pk_value = cursor.fetchone()[0]  # Get the returned PK
            conn.commit()

            print(f"Entry created successfully with ID: {new_pk_value}!")
            CTkMessagebox(title="Success", message=f"Entry created successfully! ID: {new_pk_value}", icon="check")
            refresh_table_data()

            # Update the PK field in the form (if it's a disabled Entry widget)
            if pk_entry_widget_ref and pk_detail and pk_detail['is_serial_like']:
                pk_entry_widget_ref.configure(state="normal")  # Enable temporarily
                pk_entry_widget_ref.delete(0, ctk.END)
                pk_entry_widget_ref.insert(0, str(new_pk_value))
                pk_entry_widget_ref.configure(state="disabled")  # Disable again

            form_screen.after(1500, form_screen.destroy)

        except psycopg2.Error as e:
            conn.rollback()
            print(f"Error creating entry: {e}")
            CTkMessagebox(title="Error", message=f"Failed to create entry:\n{e}", icon="cancel")

    def handle_update_entry(updated_data, original_row_data, pk_col_name, form_screen, pk_entry_widget_ref):
        """Handles updating an existing entry in the database."""
        if not pk_col_name:
            CTkMessagebox(title="Error", message="Primary key column not found for update.", icon="cancel")
            form_screen.destroy()
            return

        try:
            pk_index = column_names.index(pk_col_name)
        except ValueError:
            CTkMessagebox(title="Error",
                          message=f"Primary key '{pk_col_name}' not found in current columns. Cannot update.",
                          icon="cancel")
            form_screen.destroy()
            return

        pk_value = original_row_data[pk_index]

        set_parts = []
        values_to_set = []
        for col_name, value in updated_data.items():
            if col_name != pk_col_name:
                set_parts.append(sql.SQL("{} = %s").format(sql.Identifier(col_name)))
                values_to_set.append(value)

        if not set_parts:
            CTkMessagebox(title="No Changes", message="No fields were updated.", icon="info")
            form_screen.destroy()
            return

        update_query = sql.SQL("UPDATE {table} SET {set_clause} WHERE {pk_col} = %s").format(
            table=sql.Identifier(table_name.lower()),
            set_clause=sql.SQL(', ').join(set_parts),
            pk_col=sql.Identifier(pk_col_name)
        )

        values_to_set.append(pk_value)

        try:
            cursor.execute(update_query, tuple(values_to_set))
            conn.commit()
            print("Entry updated successfully!")
            CTkMessagebox(title="Success", message="Entry updated successfully!", icon="check")
            refresh_table_data()
        except psycopg2.Error as e:
            conn.rollback()
            print(f"Error updating entry: {e}")
            CTkMessagebox(title="Error", message=f"Failed to update entry:\n{e}", icon="cancel")
        finally:
            form_screen.destroy()

    def handle_delete_entry(row_data, pk_col_name):
        """Handles deleting an entry from the database."""
        if not pk_col_name:
            CTkMessagebox(title="Error", message="Primary key column not found for deletion.", icon="cancel")
            return

        try:
            pk_index = column_names.index(pk_col_name)
        except ValueError:
            CTkMessagebox(title="Error",
                          message=f"Primary key '{pk_col_name}' not found in current columns. Cannot delete.",
                          icon="cancel")
            return

        pk_value = row_data[pk_index]

        msg = CTkMessagebox(title="Confirm Delete",
                            message=f"Are you sure you want to delete this row (ID: {pk_value})?\n"
                                    "This action might affect related data.",
                            icon="question", option_1="No", option_2="Yes")

        response = msg.get()
        if response == "No":
            return

        try:
            delete_query = sql.SQL("DELETE FROM {table} WHERE {pk_col} = %s").format(
                table=sql.Identifier(table_name.lower()),
                pk_col=sql.Identifier(pk_col_name)
            )
            cursor.execute(delete_query, (pk_value,))
            conn.commit()
            print("Entry deleted successfully!")
            CTkMessagebox(title="Success", message="Entry deleted successfully!", icon="check")
            refresh_table_data()
        except psycopg2.Error as e:
            conn.rollback()
            print(f"Error deleting entry: {e}")
            CTkMessagebox(title="Error", message=f"Failed to delete entry. It might be referenced by other tables.\n"
                                                 "Ensure ON DELETE CASCADE is configured on foreign keys if you want cascading deletes.\n\n"
                                                 f"Details: {e}", icon="cancel")

    def show_row_context_menu(event, row, current_screen, pk_col_name_ref, table_name_ref, cursor_ref, conn_ref,
                              refresh_func, current_column_names):
        """
        Shows a right-click context menu for row operations (Update/Delete).
        """
        menu = ctk.CTkContextMenu(current_screen)

        menu.add_command(label="Update", command=lambda: create_entry_form(
            current_screen, columns_details, pk_col_name_ref, handle_update_entry, row_data=row
        ))
        menu.add_command(label="Delete", command=lambda: handle_delete_entry(row, pk_col_name_ref))

        menu.tk_popup(event.x_root, event.y_root)

    # Create button
    btn_frame = ctk.CTkFrame(screen, fg_color="#eaf0ff")
    btn_frame.pack(pady=20)

    ctk.CTkButton(btn_frame, text="Create New Entry", width=220, height=45, corner_radius=12,
                  fg_color="#007bff", hover_color="#0056b3", text_color="white",
                  font=("Segoe UI", 16, "bold"),
                  command=lambda: create_entry_form(screen, columns_details, pk_col, handle_create_entry)).pack(padx=15)

    # Initial display of data
    refresh_table_data()


# --- Example Usage (for testing) ---
if __name__ == "__main__":
    ctk.set_appearance_mode("light")
    ctk.set_default_color_theme("blue")

    root = ctk.CTk()
    root.title("DB Management System")
    root.geometry("450x350")
    root.configure(fg_color="#eaf0ff")

    conn = None
    try:
        conn = psycopg2.connect(
            dbname="airport_db",  # CHANGE THIS
            user="postgres",  # CHANGE THIS
            password="your_password",  # CHANGE THIS TO YOUR DB PASSWORD
            host="localhost"
        )
        cursor = conn.cursor()
        print("Database connection established successfully!")

    except psycopg2.Error as e:
        print(f"Error connecting to database: {e}")
        CTkMessagebox(title="DB Connection Error", message=f"Failed to connect to database:\n{e}", icon="cancel")
        root.destroy()
        exit()


    def on_closing():
        if conn:
            conn.close()
        root.destroy()


    root.protocol("WM_DELETE_WINDOW", on_closing)

    ctk.CTkLabel(root, text="Welcome to DB Manager", font=("Segoe UI", 26, "bold"),
                 fg_color="#eaf0ff", text_color="#2a3f77").pack(pady=30)

    ctk.CTkButton(root, text="Manage Incidents",
                  command=lambda: open_table_screen(cursor, "incident", conn),
                  font=("Segoe UI", 16), fg_color="#2a3f77", hover_color="#3a4f87", text_color="white",
                  width=250, height=50, corner_radius=12).pack(pady=10)

    ctk.CTkButton(root, text="Manage Areas",
                  command=lambda: open_table_screen(cursor, "area", conn),
                  font=("Segoe UI", 16), fg_color="#2a3f77", hover_color="#3a4f87", text_color="white",
                  width=250, height=50, corner_radius=12).pack(pady=10)

    ctk.CTkButton(root, text="Manage Security Personnel",
                  command=lambda: open_table_screen(cursor, "securityperson", conn),
                  font=("Segoe UI", 16), fg_color="#2a3f77", hover_color="#3a4f87", text_color="white",
                  width=250, height=50, corner_radius=12).pack(pady=10)

    root.mainloop()